#!/usr/bin/env python3
"""
MatrixMarket (.mtx) generator.

Usage examples:
  python3 generator.py -m 100 -n 100 -d 0.01 -o A.mtx
  python3 generator.py -m 4 -n 4 -d 0.5 --symmetric -o small.mtx
  python3 generator.py -m 4 -n 1 --array --integer -o vec.mtx

Generates coordinate (sparse) or array (dense) MatrixMarket files.
"""

import argparse
import random
import math
import sys


def generate_sparse_positions(m, n, nnz, symmetric=False, seed=None):
    rng = random.Random(seed)
    positions = []
    if symmetric:
        # sample positions in upper triangular (including diagonal)
        tri_count = (n*(n+1))//2 if m == n else m*n  # if not square, fallback to full
        if m != n:
            # non-square symmetric doesn't make sense; treat as general
            symmetric = False
        else:
            # map k -> (i,j) for upper-triangular index
            # choose unique indices from 0..tri_count-1
            nnz = min(nnz, tri_count)
            indices = list(range(tri_count))
            rng.shuffle(indices)
            chosen = indices[:nnz]
            for idx in chosen:
                # convert idx into (i,j)
                # triangular indexing: for row i from 0..n-1, row has (n-i) elements
                # find i such that idx < sum_{t=0..i} (n - t)
                acc = 0
                i = 0
                while i < n:
                    row_len = n - i
                    if idx < acc + row_len:
                        j = i + (idx - acc)
                        positions.append((i, j))
                        break
                    acc += row_len
                    i += 1
            return positions
    # general case: sample from all m*n positions without replacement
    total = m * n
    nnz = min(nnz, total)
    # use reservoir or random.sample
    all_indices = list(range(total))
    rng.shuffle(all_indices)
    chosen = all_indices[:nnz]
    for idx in chosen:
        i = idx // n
        j = idx % n
        positions.append((i, j))
    return positions


def write_coordinate(path, m, n, entries, real=True, pattern=False, symmetric=False):
    # entries: list of (i,j,val) 0-based
    nnz = len(entries)
    field = 'real'
    if pattern:
        field = 'pattern'
    elif not real:
        field = 'integer'
    sym = 'symmetric' if symmetric else 'general'
    with open(path, 'w') as f:
        f.write('%%MatrixMarket matrix coordinate {} {}\n'.format(field, sym))
        f.write('% generated by generator.py\n')
        f.write('{} {} {}\n'.format(m, n, nnz))
        for (i,j,v) in entries:
            if pattern:
                f.write('{} {}\n'.format(i+1, j+1))
            else:
                if real:
                    f.write('{} {} {:.12g}\n'.format(i+1, j+1, v))
                else:
                    f.write('{} {} {}\n'.format(i+1, j+1, int(round(v))))


def write_array(path, m, n, values, real=True):
    # values: list of length m*n in row-major
    field = 'real' if real else 'integer'
    with open(path, 'w') as f:
        f.write('%%MatrixMarket matrix array {} general\n'.format(field))
        f.write('% generated by generator.py\n')
        f.write('{} {}\n'.format(m, n))
        for v in values:
            if real:
                f.write('{:.12g}\n'.format(v))
            else:
                f.write('{}\n'.format(int(round(v))))


def main():
    p = argparse.ArgumentParser(description='Generate MatrixMarket (.mtx) files')
    p.add_argument('-m', '--rows', type=int, required=True, help='number of rows')
    p.add_argument('-n', '--cols', type=int, required=True, help='number of cols')
    p.add_argument('-d', '--density', type=float, default=0.1, help='density for sparse (0..1)')
    p.add_argument('-o', '--output', type=str, required=True, help='output .mtx file path')
    p.add_argument('--symmetric', action='store_true', help='make matrix symmetric (square only)')
    p.add_argument('--integer', action='store_true', help='generate integer values')
    p.add_argument('--pattern', action='store_true', help='use pattern (no values, ones)')
    p.add_argument('--array', action='store_true', help='write array (dense) format instead of coordinate')
    p.add_argument('--min', dest='vmin', type=float, default=-10.0, help='min random value')
    p.add_argument('--max', dest='vmax', type=float, default=10.0, help='max random value')
    p.add_argument('--seed', type=int, default=None, help='random seed')
    args = p.parse_args()

    if args.rows <= 0 or args.cols <= 0:
        print('rows and cols must be positive integers', file=sys.stderr); sys.exit(2)
    if args.density < 0 or args.density > 1:
        print('density must be in [0,1]', file=sys.stderr); sys.exit(2)
    if args.symmetric and args.rows != args.cols:
        print('symmetric requires square matrix (m == n). Ignoring symmetric flag.', file=sys.stderr)
        args.symmetric = False

    # handle array mode: produce dense matrix of m*n values
    if args.array:
        rng = random.Random(args.seed)
        values = []
        for i in range(args.rows * args.cols):
            if args.pattern:
                values.append(1)
            else:
                if args.integer:
                    v = rng.randint(int(math.floor(args.vmin)), int(math.ceil(args.vmax)))
                else:
                    v = rng.uniform(args.vmin, args.vmax)
                values.append(v)
        write_array(args.output, args.rows, args.cols, values, real=not args.integer)
        print('Wrote array matrix to', args.output)
        return

    # coordinate (sparse) mode
    nnz_est = int(round(args.rows * args.cols * args.density))
    nnz_est = max(nnz_est, 1) if args.density > 0 else 0
    positions = generate_sparse_positions(args.rows, args.cols, nnz_est, symmetric=args.symmetric, seed=args.seed)
    entries = []
    rng = random.Random(args.seed)
    for (i,j) in positions:
        if args.pattern:
            v = 1
        else:
            if args.integer:
                v = rng.randint(int(math.floor(args.vmin)), int(math.ceil(args.vmax)))
            else:
                v = rng.uniform(args.vmin, args.vmax)
        entries.append((i,j,v))
        if args.symmetric and i != j:
            entries.append((j,i,v))

    # Optionally combine duplicated entries (unlikely here) - keep as is
    write_coordinate(args.output, args.rows, args.cols, entries, real=not args.integer, pattern=args.pattern, symmetric=args.symmetric)
    print('Wrote coordinate matrix to', args.output, 'nnz=', len(entries))

if __name__ == '__main__':
    main()
